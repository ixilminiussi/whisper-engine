@startuml

class RenderManager {
    {static} Get() : RenderManager
    + NewWindowRenderer() : WindowID
    + CloseWindow(WindowID)
    + GetGraph(WindowID) : Graph
    + BeginRender(WindowID)
    + EndRender(WindowID)
    - CreateInstance()
}

note right of RenderManager
Singleton,
creates vulkan instance,
starts and stops device,
creates and manages window-renderer lifespans
end note

class Device {
    + Get()
}

class Renderer {
    + GetGraph()
    + Render()
}

class Graph {
    + NewPass() : Pass
    + NewResource() : Resource
    + Compile(target : Resource)
    + Render()
}

Renderer --* Graph

class Window {
    + GetSurface()
    + BindResizeCallback(callback : void *)
}

Window --* Swapchain
Window --* Surface
Window --* GLFWWindow

RenderManager --* Renderer
RenderManager --* Window
RenderManager --> Device

Renderer ..> Device
Window ..> Device

class Editor {
    + ShouldClose()
    + Render()
    + Update(Delta)
    - ViewportCamera
    - WindowID
}

class AssetsManager {
    + ImportGlTF(Path) : Node
    + LoadTexture(Texture::CreateInfo) : TextureID
    + LoadMaterial(Material::CreateInfo) : MaterialID
    + RequestImage(Image::CreateInfo) : Image
    + RequestSampler(Sampler::CreateInfo) : Sampler
    + GetTexture(TextureID) : Texture 
    + GetMaterial(MaterialID) : Material 
    + GetMesh(MeshID) : Mesh 
}

class Image {
    struct CreateInfo {}

    + Image(CreateInfo) : Image

    - BuildImage()
    - BuildCubemap()
    - GenerateMipmaps()
    - vk::Image
    - vk::DeviceMemory
}

class Sampler {
    struct CreateInfo {}

    + Sampler(CreateInfo) : Sampler

    - vk::Sampler
}

class Texture {
    struct CreateInfo {}

    + Texture(CreateInfo) : Texture

    - vk::ImageView
}

Texture --> Image
Texture --> Sampler

class Material {
    struct CreateInfo {}
     
    + Material(CreateInfo) : Material

    - TextureID albedo, normal, metallic ...
}

class Drawable {
    + virtual Bind(vk::CommandBuffer)
    + virtual Draw(vk::CommandBuffer ...)
    + BindAndDraw(vk::CommandBuffer ...)
}

class Mesh : Drawable {
    struct Primitive {
	MaterialID 
	indexCount
	indexOffset
	vertexCount
	vertexOffset
    }

    + BuildGlTF(...) : Mesh

    + virtual Bind(vk::CommandBuffer)
    + virtual Draw(vk::CommandBuffer ...)
    + PushConstant(Primitive ...)

    - vector<Primitive>
    - vk::Buffer vertex, index
    - vk::DeviceMemory vertex, index
}

class Node : Drawable {
    + virtual Bind(vk::CommandBuffer)
    + virtual Draw(vk::CommandBuffer ...)

    - Transform
    - vector<Node> children
    - MeshID // optional
}

note left of Node
draws scenes the way gltf intends.
has many children, some referencing 
same mesh, each with their own
transform. children's transform is
relative to parent's. Drawing goes
down the tree and draws all children.
end note

AssetsManager ..> Device
AssetsManager --* Image
AssetsManager --* Texture
AssetsManager --* Sampler
AssetsManager --* Material
AssetsManager --* Mesh
AssetsManager --* Node

Editor --> RenderManager
Editor --> Graph
Editor --* AssetsManager
Editor --* InputManager
Editor --> Node


@enduml
